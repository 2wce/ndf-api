// Code generated by Prisma (prisma@1.28.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  agenda: (where?: AgendaWhereInput) => Promise<boolean>;
  applicant: (where?: ApplicantWhereInput) => Promise<boolean>;
  booking: (where?: BookingWhereInput) => Promise<boolean>;
  event: (where?: EventWhereInput) => Promise<boolean>;
  member: (where?: MemberWhereInput) => Promise<boolean>;
  memberLevel: (where?: MemberLevelWhereInput) => Promise<boolean>;
  membership: (where?: MembershipWhereInput) => Promise<boolean>;
  region: (where?: RegionWhereInput) => Promise<boolean>;
  sector: (where?: SectorWhereInput) => Promise<boolean>;
  speaker: (where?: SpeakerWhereInput) => Promise<boolean>;
  sponsor: (where?: SponsorWhereInput) => Promise<boolean>;
  subscriber: (where?: SubscriberWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  agenda: (where: AgendaWhereUniqueInput) => AgendaPromise;
  agendas: (
    args?: {
      where?: AgendaWhereInput;
      orderBy?: AgendaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Agenda>;
  agendasConnection: (
    args?: {
      where?: AgendaWhereInput;
      orderBy?: AgendaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AgendaConnectionPromise;
  applicant: (where: ApplicantWhereUniqueInput) => ApplicantPromise;
  applicants: (
    args?: {
      where?: ApplicantWhereInput;
      orderBy?: ApplicantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Applicant>;
  applicantsConnection: (
    args?: {
      where?: ApplicantWhereInput;
      orderBy?: ApplicantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ApplicantConnectionPromise;
  booking: (where: BookingWhereUniqueInput) => BookingPromise;
  bookings: (
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Booking>;
  bookingsConnection: (
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BookingConnectionPromise;
  event: (where: EventWhereUniqueInput) => EventPromise;
  events: (
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Event>;
  eventsConnection: (
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => EventConnectionPromise;
  member: (where: MemberWhereUniqueInput) => MemberPromise;
  members: (
    args?: {
      where?: MemberWhereInput;
      orderBy?: MemberOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Member>;
  membersConnection: (
    args?: {
      where?: MemberWhereInput;
      orderBy?: MemberOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MemberConnectionPromise;
  memberLevel: (where: MemberLevelWhereUniqueInput) => MemberLevelPromise;
  memberLevels: (
    args?: {
      where?: MemberLevelWhereInput;
      orderBy?: MemberLevelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<MemberLevel>;
  memberLevelsConnection: (
    args?: {
      where?: MemberLevelWhereInput;
      orderBy?: MemberLevelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MemberLevelConnectionPromise;
  membership: (where: MembershipWhereUniqueInput) => MembershipPromise;
  memberships: (
    args?: {
      where?: MembershipWhereInput;
      orderBy?: MembershipOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Membership>;
  membershipsConnection: (
    args?: {
      where?: MembershipWhereInput;
      orderBy?: MembershipOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MembershipConnectionPromise;
  region: (where: RegionWhereUniqueInput) => RegionPromise;
  regions: (
    args?: {
      where?: RegionWhereInput;
      orderBy?: RegionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Region>;
  regionsConnection: (
    args?: {
      where?: RegionWhereInput;
      orderBy?: RegionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RegionConnectionPromise;
  sector: (where: SectorWhereUniqueInput) => SectorPromise;
  sectors: (
    args?: {
      where?: SectorWhereInput;
      orderBy?: SectorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Sector>;
  sectorsConnection: (
    args?: {
      where?: SectorWhereInput;
      orderBy?: SectorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SectorConnectionPromise;
  speaker: (where: SpeakerWhereUniqueInput) => SpeakerPromise;
  speakers: (
    args?: {
      where?: SpeakerWhereInput;
      orderBy?: SpeakerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Speaker>;
  speakersConnection: (
    args?: {
      where?: SpeakerWhereInput;
      orderBy?: SpeakerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SpeakerConnectionPromise;
  sponsor: (where: SponsorWhereUniqueInput) => SponsorPromise;
  sponsors: (
    args?: {
      where?: SponsorWhereInput;
      orderBy?: SponsorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Sponsor>;
  sponsorsConnection: (
    args?: {
      where?: SponsorWhereInput;
      orderBy?: SponsorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SponsorConnectionPromise;
  subscriber: (where: SubscriberWhereUniqueInput) => SubscriberPromise;
  subscribers: (
    args?: {
      where?: SubscriberWhereInput;
      orderBy?: SubscriberOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Subscriber>;
  subscribersConnection: (
    args?: {
      where?: SubscriberWhereInput;
      orderBy?: SubscriberOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SubscriberConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAgenda: (data: AgendaCreateInput) => AgendaPromise;
  updateAgenda: (
    args: { data: AgendaUpdateInput; where: AgendaWhereUniqueInput }
  ) => AgendaPromise;
  updateManyAgendas: (
    args: { data: AgendaUpdateManyMutationInput; where?: AgendaWhereInput }
  ) => BatchPayloadPromise;
  upsertAgenda: (
    args: {
      where: AgendaWhereUniqueInput;
      create: AgendaCreateInput;
      update: AgendaUpdateInput;
    }
  ) => AgendaPromise;
  deleteAgenda: (where: AgendaWhereUniqueInput) => AgendaPromise;
  deleteManyAgendas: (where?: AgendaWhereInput) => BatchPayloadPromise;
  createApplicant: (data: ApplicantCreateInput) => ApplicantPromise;
  updateApplicant: (
    args: { data: ApplicantUpdateInput; where: ApplicantWhereUniqueInput }
  ) => ApplicantPromise;
  updateManyApplicants: (
    args: {
      data: ApplicantUpdateManyMutationInput;
      where?: ApplicantWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertApplicant: (
    args: {
      where: ApplicantWhereUniqueInput;
      create: ApplicantCreateInput;
      update: ApplicantUpdateInput;
    }
  ) => ApplicantPromise;
  deleteApplicant: (where: ApplicantWhereUniqueInput) => ApplicantPromise;
  deleteManyApplicants: (where?: ApplicantWhereInput) => BatchPayloadPromise;
  createBooking: (data: BookingCreateInput) => BookingPromise;
  updateBooking: (
    args: { data: BookingUpdateInput; where: BookingWhereUniqueInput }
  ) => BookingPromise;
  upsertBooking: (
    args: {
      where: BookingWhereUniqueInput;
      create: BookingCreateInput;
      update: BookingUpdateInput;
    }
  ) => BookingPromise;
  deleteBooking: (where: BookingWhereUniqueInput) => BookingPromise;
  deleteManyBookings: (where?: BookingWhereInput) => BatchPayloadPromise;
  createEvent: (data: EventCreateInput) => EventPromise;
  updateEvent: (
    args: { data: EventUpdateInput; where: EventWhereUniqueInput }
  ) => EventPromise;
  updateManyEvents: (
    args: { data: EventUpdateManyMutationInput; where?: EventWhereInput }
  ) => BatchPayloadPromise;
  upsertEvent: (
    args: {
      where: EventWhereUniqueInput;
      create: EventCreateInput;
      update: EventUpdateInput;
    }
  ) => EventPromise;
  deleteEvent: (where: EventWhereUniqueInput) => EventPromise;
  deleteManyEvents: (where?: EventWhereInput) => BatchPayloadPromise;
  createMember: (data: MemberCreateInput) => MemberPromise;
  updateMember: (
    args: { data: MemberUpdateInput; where: MemberWhereUniqueInput }
  ) => MemberPromise;
  updateManyMembers: (
    args: { data: MemberUpdateManyMutationInput; where?: MemberWhereInput }
  ) => BatchPayloadPromise;
  upsertMember: (
    args: {
      where: MemberWhereUniqueInput;
      create: MemberCreateInput;
      update: MemberUpdateInput;
    }
  ) => MemberPromise;
  deleteMember: (where: MemberWhereUniqueInput) => MemberPromise;
  deleteManyMembers: (where?: MemberWhereInput) => BatchPayloadPromise;
  createMemberLevel: (data: MemberLevelCreateInput) => MemberLevelPromise;
  updateMemberLevel: (
    args: { data: MemberLevelUpdateInput; where: MemberLevelWhereUniqueInput }
  ) => MemberLevelPromise;
  updateManyMemberLevels: (
    args: {
      data: MemberLevelUpdateManyMutationInput;
      where?: MemberLevelWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertMemberLevel: (
    args: {
      where: MemberLevelWhereUniqueInput;
      create: MemberLevelCreateInput;
      update: MemberLevelUpdateInput;
    }
  ) => MemberLevelPromise;
  deleteMemberLevel: (where: MemberLevelWhereUniqueInput) => MemberLevelPromise;
  deleteManyMemberLevels: (
    where?: MemberLevelWhereInput
  ) => BatchPayloadPromise;
  createMembership: (data: MembershipCreateInput) => MembershipPromise;
  updateMembership: (
    args: { data: MembershipUpdateInput; where: MembershipWhereUniqueInput }
  ) => MembershipPromise;
  updateManyMemberships: (
    args: {
      data: MembershipUpdateManyMutationInput;
      where?: MembershipWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertMembership: (
    args: {
      where: MembershipWhereUniqueInput;
      create: MembershipCreateInput;
      update: MembershipUpdateInput;
    }
  ) => MembershipPromise;
  deleteMembership: (where: MembershipWhereUniqueInput) => MembershipPromise;
  deleteManyMemberships: (where?: MembershipWhereInput) => BatchPayloadPromise;
  createRegion: (data: RegionCreateInput) => RegionPromise;
  updateRegion: (
    args: { data: RegionUpdateInput; where: RegionWhereUniqueInput }
  ) => RegionPromise;
  updateManyRegions: (
    args: { data: RegionUpdateManyMutationInput; where?: RegionWhereInput }
  ) => BatchPayloadPromise;
  upsertRegion: (
    args: {
      where: RegionWhereUniqueInput;
      create: RegionCreateInput;
      update: RegionUpdateInput;
    }
  ) => RegionPromise;
  deleteRegion: (where: RegionWhereUniqueInput) => RegionPromise;
  deleteManyRegions: (where?: RegionWhereInput) => BatchPayloadPromise;
  createSector: (data: SectorCreateInput) => SectorPromise;
  updateSector: (
    args: { data: SectorUpdateInput; where: SectorWhereUniqueInput }
  ) => SectorPromise;
  updateManySectors: (
    args: { data: SectorUpdateManyMutationInput; where?: SectorWhereInput }
  ) => BatchPayloadPromise;
  upsertSector: (
    args: {
      where: SectorWhereUniqueInput;
      create: SectorCreateInput;
      update: SectorUpdateInput;
    }
  ) => SectorPromise;
  deleteSector: (where: SectorWhereUniqueInput) => SectorPromise;
  deleteManySectors: (where?: SectorWhereInput) => BatchPayloadPromise;
  createSpeaker: (data: SpeakerCreateInput) => SpeakerPromise;
  updateSpeaker: (
    args: { data: SpeakerUpdateInput; where: SpeakerWhereUniqueInput }
  ) => SpeakerPromise;
  updateManySpeakers: (
    args: { data: SpeakerUpdateManyMutationInput; where?: SpeakerWhereInput }
  ) => BatchPayloadPromise;
  upsertSpeaker: (
    args: {
      where: SpeakerWhereUniqueInput;
      create: SpeakerCreateInput;
      update: SpeakerUpdateInput;
    }
  ) => SpeakerPromise;
  deleteSpeaker: (where: SpeakerWhereUniqueInput) => SpeakerPromise;
  deleteManySpeakers: (where?: SpeakerWhereInput) => BatchPayloadPromise;
  createSponsor: (data: SponsorCreateInput) => SponsorPromise;
  updateSponsor: (
    args: { data: SponsorUpdateInput; where: SponsorWhereUniqueInput }
  ) => SponsorPromise;
  updateManySponsors: (
    args: { data: SponsorUpdateManyMutationInput; where?: SponsorWhereInput }
  ) => BatchPayloadPromise;
  upsertSponsor: (
    args: {
      where: SponsorWhereUniqueInput;
      create: SponsorCreateInput;
      update: SponsorUpdateInput;
    }
  ) => SponsorPromise;
  deleteSponsor: (where: SponsorWhereUniqueInput) => SponsorPromise;
  deleteManySponsors: (where?: SponsorWhereInput) => BatchPayloadPromise;
  createSubscriber: (data: SubscriberCreateInput) => SubscriberPromise;
  updateSubscriber: (
    args: { data: SubscriberUpdateInput; where: SubscriberWhereUniqueInput }
  ) => SubscriberPromise;
  updateManySubscribers: (
    args: {
      data: SubscriberUpdateManyMutationInput;
      where?: SubscriberWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSubscriber: (
    args: {
      where: SubscriberWhereUniqueInput;
      create: SubscriberCreateInput;
      update: SubscriberUpdateInput;
    }
  ) => SubscriberPromise;
  deleteSubscriber: (where: SubscriberWhereUniqueInput) => SubscriberPromise;
  deleteManySubscribers: (where?: SubscriberWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  agenda: (
    where?: AgendaSubscriptionWhereInput
  ) => AgendaSubscriptionPayloadSubscription;
  applicant: (
    where?: ApplicantSubscriptionWhereInput
  ) => ApplicantSubscriptionPayloadSubscription;
  booking: (
    where?: BookingSubscriptionWhereInput
  ) => BookingSubscriptionPayloadSubscription;
  event: (
    where?: EventSubscriptionWhereInput
  ) => EventSubscriptionPayloadSubscription;
  member: (
    where?: MemberSubscriptionWhereInput
  ) => MemberSubscriptionPayloadSubscription;
  memberLevel: (
    where?: MemberLevelSubscriptionWhereInput
  ) => MemberLevelSubscriptionPayloadSubscription;
  membership: (
    where?: MembershipSubscriptionWhereInput
  ) => MembershipSubscriptionPayloadSubscription;
  region: (
    where?: RegionSubscriptionWhereInput
  ) => RegionSubscriptionPayloadSubscription;
  sector: (
    where?: SectorSubscriptionWhereInput
  ) => SectorSubscriptionPayloadSubscription;
  speaker: (
    where?: SpeakerSubscriptionWhereInput
  ) => SpeakerSubscriptionPayloadSubscription;
  sponsor: (
    where?: SponsorSubscriptionWhereInput
  ) => SponsorSubscriptionPayloadSubscription;
  subscriber: (
    where?: SubscriberSubscriptionWhereInput
  ) => SubscriberSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type SponsorOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "avatar_ASC"
  | "avatar_DESC"
  | "name_ASC"
  | "name_DESC";

export type ApplicantOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "type_ASC"
  | "type_DESC"
  | "companyName_ASC"
  | "companyName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "jobTitle_ASC"
  | "jobTitle_DESC"
  | "name_ASC"
  | "name_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC";

export type SpeakerOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "jobTitle_ASC"
  | "jobTitle_DESC"
  | "avatar_ASC"
  | "avatar_DESC"
  | "name_ASC"
  | "name_DESC";

export type SubscriberOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "email_ASC"
  | "email_DESC";

export type EventOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "communityTag_ASC"
  | "communityTag_DESC"
  | "date_ASC"
  | "date_DESC"
  | "description_ASC"
  | "description_DESC"
  | "name_ASC"
  | "name_DESC"
  | "time_ASC"
  | "time_DESC"
  | "coordinator_ASC"
  | "coordinator_DESC"
  | "type_ASC"
  | "type_DESC";

export type RegionOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC";

export type MemberLevelOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "subscription_ASC"
  | "subscription_DESC";

export type MembershipOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "type_ASC"
  | "type_DESC";

export type LevelName =
  | "MEMBER"
  | "ASSOCIATE"
  | "PARTNER"
  | "STRATEGIC_PARTNER";

export type MemberType = "INDIVIDUAL" | "INSTITUTIONAL";

export type EventType =
  | "MEMBER_EVENT"
  | "CORPORATE_EVENT"
  | "RESEARCH_EVENT"
  | "CONFERENCE"
  | "SPECIAL_EVENT";

export type BookingOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MemberOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "type_ASC"
  | "type_DESC"
  | "companyName_ASC"
  | "companyName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "isAdmin_ASC"
  | "isAdmin_DESC"
  | "jobTitle_ASC"
  | "jobTitle_DESC"
  | "name_ASC"
  | "name_DESC"
  | "password_ASC"
  | "password_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "profilePicture_ASC"
  | "profilePicture_DESC";

export type AgendaOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "description_ASC"
  | "description_DESC"
  | "image_ASC"
  | "image_DESC"
  | "name_ASC"
  | "name_DESC";

export type SectorOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "description_ASC"
  | "description_DESC"
  | "name_ASC"
  | "name_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface EventCreateManyWithoutMemberLevelInput {
  create?:
    | EventCreateWithoutMemberLevelInput[]
    | EventCreateWithoutMemberLevelInput;
  connect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
}

export type AgendaWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BookingUpdateManyWithoutEventInput {
  create?: BookingCreateWithoutEventInput[] | BookingCreateWithoutEventInput;
  delete?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  set?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  disconnect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  update?:
    | BookingUpdateWithWhereUniqueWithoutEventInput[]
    | BookingUpdateWithWhereUniqueWithoutEventInput;
  upsert?:
    | BookingUpsertWithWhereUniqueWithoutEventInput[]
    | BookingUpsertWithWhereUniqueWithoutEventInput;
  deleteMany?: BookingScalarWhereInput[] | BookingScalarWhereInput;
}

export interface MemberLevelUpdateOneInput {
  create?: MemberLevelCreateInput;
  update?: MemberLevelUpdateDataInput;
  upsert?: MemberLevelUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MemberLevelWhereUniqueInput;
}

export interface AgendaUpsertNestedInput {
  update: AgendaUpdateDataInput;
  create: AgendaCreateInput;
}

export type BookingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AgendaCreateInput {
  description?: String;
  image?: String;
  name: String;
}

export interface SpeakerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SpeakerWhereInput;
  AND?: SpeakerSubscriptionWhereInput[] | SpeakerSubscriptionWhereInput;
  OR?: SpeakerSubscriptionWhereInput[] | SpeakerSubscriptionWhereInput;
  NOT?: SpeakerSubscriptionWhereInput[] | SpeakerSubscriptionWhereInput;
}

export interface AgendaUpdateInput {
  description?: String;
  image?: String;
  name?: String;
}

export interface EventWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  communityTag?: String;
  communityTag_not?: String;
  communityTag_in?: String[] | String;
  communityTag_not_in?: String[] | String;
  communityTag_lt?: String;
  communityTag_lte?: String;
  communityTag_gt?: String;
  communityTag_gte?: String;
  communityTag_contains?: String;
  communityTag_not_contains?: String;
  communityTag_starts_with?: String;
  communityTag_not_starts_with?: String;
  communityTag_ends_with?: String;
  communityTag_not_ends_with?: String;
  date?: String;
  date_not?: String;
  date_in?: String[] | String;
  date_not_in?: String[] | String;
  date_lt?: String;
  date_lte?: String;
  date_gt?: String;
  date_gte?: String;
  date_contains?: String;
  date_not_contains?: String;
  date_starts_with?: String;
  date_not_starts_with?: String;
  date_ends_with?: String;
  date_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  time?: String;
  time_not?: String;
  time_in?: String[] | String;
  time_not_in?: String[] | String;
  time_lt?: String;
  time_lte?: String;
  time_gt?: String;
  time_gte?: String;
  time_contains?: String;
  time_not_contains?: String;
  time_starts_with?: String;
  time_not_starts_with?: String;
  time_ends_with?: String;
  time_not_ends_with?: String;
  agenda?: AgendaWhereInput;
  bookings_every?: BookingWhereInput;
  bookings_some?: BookingWhereInput;
  bookings_none?: BookingWhereInput;
  coordinator?: String;
  coordinator_not?: String;
  coordinator_in?: String[] | String;
  coordinator_not_in?: String[] | String;
  coordinator_lt?: String;
  coordinator_lte?: String;
  coordinator_gt?: String;
  coordinator_gte?: String;
  coordinator_contains?: String;
  coordinator_not_contains?: String;
  coordinator_starts_with?: String;
  coordinator_not_starts_with?: String;
  coordinator_ends_with?: String;
  coordinator_not_ends_with?: String;
  memberLevel_every?: MemberLevelWhereInput;
  memberLevel_some?: MemberLevelWhereInput;
  memberLevel_none?: MemberLevelWhereInput;
  region?: RegionWhereInput;
  sector?: SectorWhereInput;
  speakers_every?: SpeakerWhereInput;
  speakers_some?: SpeakerWhereInput;
  speakers_none?: SpeakerWhereInput;
  sponsors_every?: SponsorWhereInput;
  sponsors_some?: SponsorWhereInput;
  sponsors_none?: SponsorWhereInput;
  type?: EventType;
  type_not?: EventType;
  type_in?: EventType[] | EventType;
  type_not_in?: EventType[] | EventType;
  AND?: EventWhereInput[] | EventWhereInput;
  OR?: EventWhereInput[] | EventWhereInput;
  NOT?: EventWhereInput[] | EventWhereInput;
}

export interface AgendaUpdateManyMutationInput {
  description?: String;
  image?: String;
  name?: String;
}

export interface ApplicantWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  type?: MemberType;
  type_not?: MemberType;
  type_in?: MemberType[] | MemberType;
  type_not_in?: MemberType[] | MemberType;
  companyName?: String;
  companyName_not?: String;
  companyName_in?: String[] | String;
  companyName_not_in?: String[] | String;
  companyName_lt?: String;
  companyName_lte?: String;
  companyName_gt?: String;
  companyName_gte?: String;
  companyName_contains?: String;
  companyName_not_contains?: String;
  companyName_starts_with?: String;
  companyName_not_starts_with?: String;
  companyName_ends_with?: String;
  companyName_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  jobTitle?: String;
  jobTitle_not?: String;
  jobTitle_in?: String[] | String;
  jobTitle_not_in?: String[] | String;
  jobTitle_lt?: String;
  jobTitle_lte?: String;
  jobTitle_gt?: String;
  jobTitle_gte?: String;
  jobTitle_contains?: String;
  jobTitle_not_contains?: String;
  jobTitle_starts_with?: String;
  jobTitle_not_starts_with?: String;
  jobTitle_ends_with?: String;
  jobTitle_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  phoneNumber?: String;
  phoneNumber_not?: String;
  phoneNumber_in?: String[] | String;
  phoneNumber_not_in?: String[] | String;
  phoneNumber_lt?: String;
  phoneNumber_lte?: String;
  phoneNumber_gt?: String;
  phoneNumber_gte?: String;
  phoneNumber_contains?: String;
  phoneNumber_not_contains?: String;
  phoneNumber_starts_with?: String;
  phoneNumber_not_starts_with?: String;
  phoneNumber_ends_with?: String;
  phoneNumber_not_ends_with?: String;
  AND?: ApplicantWhereInput[] | ApplicantWhereInput;
  OR?: ApplicantWhereInput[] | ApplicantWhereInput;
  NOT?: ApplicantWhereInput[] | ApplicantWhereInput;
}

export interface EventUpdateWithoutMemberLevelDataInput {
  communityTag?: String;
  date?: String;
  description?: String;
  name?: String;
  time?: String;
  agenda?: AgendaUpdateOneInput;
  bookings?: BookingUpdateManyWithoutEventInput;
  coordinator?: String;
  region?: RegionUpdateOneInput;
  sector?: SectorUpdateOneInput;
  speakers?: SpeakerUpdateManyInput;
  sponsors?: SponsorUpdateManyInput;
  type?: EventType;
}

export interface SectorWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: SectorWhereInput[] | SectorWhereInput;
  OR?: SectorWhereInput[] | SectorWhereInput;
  NOT?: SectorWhereInput[] | SectorWhereInput;
}

export interface EventUpdateWithWhereUniqueWithoutMemberLevelInput {
  where: EventWhereUniqueInput;
  data: EventUpdateWithoutMemberLevelDataInput;
}

export interface SponsorWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  avatar?: String;
  avatar_not?: String;
  avatar_in?: String[] | String;
  avatar_not_in?: String[] | String;
  avatar_lt?: String;
  avatar_lte?: String;
  avatar_gt?: String;
  avatar_gte?: String;
  avatar_contains?: String;
  avatar_not_contains?: String;
  avatar_starts_with?: String;
  avatar_not_starts_with?: String;
  avatar_ends_with?: String;
  avatar_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: SponsorWhereInput[] | SponsorWhereInput;
  OR?: SponsorWhereInput[] | SponsorWhereInput;
  NOT?: SponsorWhereInput[] | SponsorWhereInput;
}

export interface ApplicantCreateInput {
  type?: MemberType;
  companyName?: String;
  email: String;
  jobTitle?: String;
  name?: String;
  phoneNumber?: String;
}

export interface MemberWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  type?: MemberType;
  type_not?: MemberType;
  type_in?: MemberType[] | MemberType;
  type_not_in?: MemberType[] | MemberType;
  membership?: MembershipWhereInput;
  companyName?: String;
  companyName_not?: String;
  companyName_in?: String[] | String;
  companyName_not_in?: String[] | String;
  companyName_lt?: String;
  companyName_lte?: String;
  companyName_gt?: String;
  companyName_gte?: String;
  companyName_contains?: String;
  companyName_not_contains?: String;
  companyName_starts_with?: String;
  companyName_not_starts_with?: String;
  companyName_ends_with?: String;
  companyName_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  isAdmin?: Boolean;
  isAdmin_not?: Boolean;
  jobTitle?: String;
  jobTitle_not?: String;
  jobTitle_in?: String[] | String;
  jobTitle_not_in?: String[] | String;
  jobTitle_lt?: String;
  jobTitle_lte?: String;
  jobTitle_gt?: String;
  jobTitle_gte?: String;
  jobTitle_contains?: String;
  jobTitle_not_contains?: String;
  jobTitle_starts_with?: String;
  jobTitle_not_starts_with?: String;
  jobTitle_ends_with?: String;
  jobTitle_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  phoneNumber?: String;
  phoneNumber_not?: String;
  phoneNumber_in?: String[] | String;
  phoneNumber_not_in?: String[] | String;
  phoneNumber_lt?: String;
  phoneNumber_lte?: String;
  phoneNumber_gt?: String;
  phoneNumber_gte?: String;
  phoneNumber_contains?: String;
  phoneNumber_not_contains?: String;
  phoneNumber_starts_with?: String;
  phoneNumber_not_starts_with?: String;
  phoneNumber_ends_with?: String;
  phoneNumber_not_ends_with?: String;
  profilePicture?: String;
  profilePicture_not?: String;
  profilePicture_in?: String[] | String;
  profilePicture_not_in?: String[] | String;
  profilePicture_lt?: String;
  profilePicture_lte?: String;
  profilePicture_gt?: String;
  profilePicture_gte?: String;
  profilePicture_contains?: String;
  profilePicture_not_contains?: String;
  profilePicture_starts_with?: String;
  profilePicture_not_starts_with?: String;
  profilePicture_ends_with?: String;
  profilePicture_not_ends_with?: String;
  AND?: MemberWhereInput[] | MemberWhereInput;
  OR?: MemberWhereInput[] | MemberWhereInput;
  NOT?: MemberWhereInput[] | MemberWhereInput;
}

export interface ApplicantUpdateInput {
  type?: MemberType;
  companyName?: String;
  email?: String;
  jobTitle?: String;
  name?: String;
  phoneNumber?: String;
}

export type ApplicantWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface ApplicantUpdateManyMutationInput {
  type?: MemberType;
  companyName?: String;
  email?: String;
  jobTitle?: String;
  name?: String;
  phoneNumber?: String;
}

export interface MembershipSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MembershipWhereInput;
  AND?: MembershipSubscriptionWhereInput[] | MembershipSubscriptionWhereInput;
  OR?: MembershipSubscriptionWhereInput[] | MembershipSubscriptionWhereInput;
  NOT?: MembershipSubscriptionWhereInput[] | MembershipSubscriptionWhereInput;
}

export interface BookingCreateInput {
  event?: EventCreateOneWithoutBookingsInput;
  member?: MemberCreateOneInput;
}

export interface MemberSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MemberWhereInput;
  AND?: MemberSubscriptionWhereInput[] | MemberSubscriptionWhereInput;
  OR?: MemberSubscriptionWhereInput[] | MemberSubscriptionWhereInput;
  NOT?: MemberSubscriptionWhereInput[] | MemberSubscriptionWhereInput;
}

export interface EventCreateOneWithoutBookingsInput {
  create?: EventCreateWithoutBookingsInput;
  connect?: EventWhereUniqueInput;
}

export interface BookingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BookingWhereInput;
  AND?: BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput;
  OR?: BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput;
  NOT?: BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput;
}

export interface EventCreateWithoutBookingsInput {
  communityTag?: String;
  date?: String;
  description?: String;
  name: String;
  time?: String;
  agenda?: AgendaCreateOneInput;
  coordinator?: String;
  memberLevel?: MemberLevelCreateManyWithoutEventInput;
  region?: RegionCreateOneInput;
  sector?: SectorCreateOneInput;
  speakers?: SpeakerCreateManyInput;
  sponsors?: SponsorCreateManyInput;
  type?: EventType;
}

export interface AgendaSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AgendaWhereInput;
  AND?: AgendaSubscriptionWhereInput[] | AgendaSubscriptionWhereInput;
  OR?: AgendaSubscriptionWhereInput[] | AgendaSubscriptionWhereInput;
  NOT?: AgendaSubscriptionWhereInput[] | AgendaSubscriptionWhereInput;
}

export interface AgendaCreateOneInput {
  create?: AgendaCreateInput;
  connect?: AgendaWhereUniqueInput;
}

export interface SubscriberUpdateInput {
  email?: String;
}

export interface MemberLevelCreateManyWithoutEventInput {
  create?:
    | MemberLevelCreateWithoutEventInput[]
    | MemberLevelCreateWithoutEventInput;
  connect?: MemberLevelWhereUniqueInput[] | MemberLevelWhereUniqueInput;
}

export interface SponsorUpdateManyMutationInput {
  avatar?: String;
  name?: String;
}

export interface MemberLevelCreateWithoutEventInput {
  name?: LevelName;
  subscription?: String;
}

export interface SpeakerUpdateManyMutationInput {
  jobTitle?: String;
  avatar?: String;
  name?: String;
}

export interface RegionCreateOneInput {
  create?: RegionCreateInput;
  connect?: RegionWhereUniqueInput;
}

export interface SpeakerUpdateInput {
  jobTitle?: String;
  avatar?: String;
  name?: String;
}

export interface RegionCreateInput {
  name?: String;
}

export interface SectorUpdateInput {
  description?: String;
  name?: String;
}

export interface SectorCreateOneInput {
  create?: SectorCreateInput;
  connect?: SectorWhereUniqueInput;
}

export interface RegionUpdateManyMutationInput {
  name?: String;
}

export interface SectorCreateInput {
  description?: String;
  name: String;
}

export interface MembershipUpdateManyMutationInput {
  type?: MemberType;
}

export interface SpeakerCreateManyInput {
  create?: SpeakerCreateInput[] | SpeakerCreateInput;
  connect?: SpeakerWhereUniqueInput[] | SpeakerWhereUniqueInput;
}

export type MemberLevelWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SpeakerCreateInput {
  jobTitle?: String;
  avatar?: String;
  name: String;
}

export interface MemberUpdateOneWithoutMembershipInput {
  create?: MemberCreateWithoutMembershipInput;
  update?: MemberUpdateWithoutMembershipDataInput;
  upsert?: MemberUpsertWithoutMembershipInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MemberWhereUniqueInput;
}

export interface SponsorCreateManyInput {
  create?: SponsorCreateInput[] | SponsorCreateInput;
  connect?: SponsorWhereUniqueInput[] | SponsorWhereUniqueInput;
}

export type MembershipWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SponsorCreateInput {
  avatar?: String;
  name: String;
}

export interface MemberCreateOneWithoutMembershipInput {
  create?: MemberCreateWithoutMembershipInput;
  connect?: MemberWhereUniqueInput;
}

export interface MemberCreateOneInput {
  create?: MemberCreateInput;
  connect?: MemberWhereUniqueInput;
}

export interface MemberLevelUpdateManyMutationInput {
  name?: LevelName;
  subscription?: String;
}

export interface MemberCreateInput {
  type?: MemberType;
  membership?: MembershipCreateOneWithoutMemberInput;
  companyName?: String;
  email: String;
  isAdmin?: Boolean;
  jobTitle?: String;
  name?: String;
  password?: String;
  phoneNumber?: String;
  profilePicture?: String;
}

export interface AgendaWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: AgendaWhereInput[] | AgendaWhereInput;
  OR?: AgendaWhereInput[] | AgendaWhereInput;
  NOT?: AgendaWhereInput[] | AgendaWhereInput;
}

export interface MembershipCreateOneWithoutMemberInput {
  create?: MembershipCreateWithoutMemberInput;
  connect?: MembershipWhereUniqueInput;
}

export interface MemberUpdateManyMutationInput {
  type?: MemberType;
  companyName?: String;
  email?: String;
  isAdmin?: Boolean;
  jobTitle?: String;
  name?: String;
  password?: String;
  phoneNumber?: String;
  profilePicture?: String;
}

export interface MembershipCreateWithoutMemberInput {
  type?: MemberType;
  level?: MemberLevelCreateOneInput;
}

export type SectorWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface MemberLevelCreateOneInput {
  create?: MemberLevelCreateInput;
  connect?: MemberLevelWhereUniqueInput;
}

export interface EventUpdateInput {
  communityTag?: String;
  date?: String;
  description?: String;
  name?: String;
  time?: String;
  agenda?: AgendaUpdateOneInput;
  bookings?: BookingUpdateManyWithoutEventInput;
  coordinator?: String;
  memberLevel?: MemberLevelUpdateManyWithoutEventInput;
  region?: RegionUpdateOneInput;
  sector?: SectorUpdateOneInput;
  speakers?: SpeakerUpdateManyInput;
  sponsors?: SponsorUpdateManyInput;
  type?: EventType;
}

export interface MemberLevelCreateInput {
  name?: LevelName;
  subscription?: String;
  event?: EventCreateManyWithoutMemberLevelInput;
}

export interface MemberUpsertNestedInput {
  update: MemberUpdateDataInput;
  create: MemberCreateInput;
}

export interface EventUpdateManyWithoutMemberLevelInput {
  create?:
    | EventCreateWithoutMemberLevelInput[]
    | EventCreateWithoutMemberLevelInput;
  delete?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  connect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  set?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  disconnect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  update?:
    | EventUpdateWithWhereUniqueWithoutMemberLevelInput[]
    | EventUpdateWithWhereUniqueWithoutMemberLevelInput;
  upsert?:
    | EventUpsertWithWhereUniqueWithoutMemberLevelInput[]
    | EventUpsertWithWhereUniqueWithoutMemberLevelInput;
  deleteMany?: EventScalarWhereInput[] | EventScalarWhereInput;
  updateMany?:
    | EventUpdateManyWithWhereNestedInput[]
    | EventUpdateManyWithWhereNestedInput;
}

export interface MembershipUpsertWithoutMemberInput {
  update: MembershipUpdateWithoutMemberDataInput;
  create: MembershipCreateWithoutMemberInput;
}

export interface EventCreateWithoutMemberLevelInput {
  communityTag?: String;
  date?: String;
  description?: String;
  name: String;
  time?: String;
  agenda?: AgendaCreateOneInput;
  bookings?: BookingCreateManyWithoutEventInput;
  coordinator?: String;
  region?: RegionCreateOneInput;
  sector?: SectorCreateOneInput;
  speakers?: SpeakerCreateManyInput;
  sponsors?: SponsorCreateManyInput;
  type?: EventType;
}

export interface EventUpdateManyDataInput {
  communityTag?: String;
  date?: String;
  description?: String;
  name?: String;
  time?: String;
  coordinator?: String;
  type?: EventType;
}

export interface BookingCreateManyWithoutEventInput {
  create?: BookingCreateWithoutEventInput[] | BookingCreateWithoutEventInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
}

export interface EventUpdateManyWithWhereNestedInput {
  where: EventScalarWhereInput;
  data: EventUpdateManyDataInput;
}

export interface BookingCreateWithoutEventInput {
  member?: MemberCreateOneInput;
}

export interface EventUpsertWithWhereUniqueWithoutMemberLevelInput {
  where: EventWhereUniqueInput;
  update: EventUpdateWithoutMemberLevelDataInput;
  create: EventCreateWithoutMemberLevelInput;
}

export interface BookingUpdateInput {
  event?: EventUpdateOneWithoutBookingsInput;
  member?: MemberUpdateOneInput;
}

export interface BookingScalarWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: BookingScalarWhereInput[] | BookingScalarWhereInput;
  OR?: BookingScalarWhereInput[] | BookingScalarWhereInput;
  NOT?: BookingScalarWhereInput[] | BookingScalarWhereInput;
}

export interface EventUpdateOneWithoutBookingsInput {
  create?: EventCreateWithoutBookingsInput;
  update?: EventUpdateWithoutBookingsDataInput;
  upsert?: EventUpsertWithoutBookingsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: EventWhereUniqueInput;
}

export interface BookingUpsertWithWhereUniqueWithoutEventInput {
  where: BookingWhereUniqueInput;
  update: BookingUpdateWithoutEventDataInput;
  create: BookingCreateWithoutEventInput;
}

export interface EventUpdateWithoutBookingsDataInput {
  communityTag?: String;
  date?: String;
  description?: String;
  name?: String;
  time?: String;
  agenda?: AgendaUpdateOneInput;
  coordinator?: String;
  memberLevel?: MemberLevelUpdateManyWithoutEventInput;
  region?: RegionUpdateOneInput;
  sector?: SectorUpdateOneInput;
  speakers?: SpeakerUpdateManyInput;
  sponsors?: SponsorUpdateManyInput;
  type?: EventType;
}

export interface BookingUpdateWithWhereUniqueWithoutEventInput {
  where: BookingWhereUniqueInput;
  data: BookingUpdateWithoutEventDataInput;
}

export interface AgendaUpdateOneInput {
  create?: AgendaCreateInput;
  update?: AgendaUpdateDataInput;
  upsert?: AgendaUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: AgendaWhereUniqueInput;
}

export interface SponsorSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SponsorWhereInput;
  AND?: SponsorSubscriptionWhereInput[] | SponsorSubscriptionWhereInput;
  OR?: SponsorSubscriptionWhereInput[] | SponsorSubscriptionWhereInput;
  NOT?: SponsorSubscriptionWhereInput[] | SponsorSubscriptionWhereInput;
}

export interface AgendaUpdateDataInput {
  description?: String;
  image?: String;
  name?: String;
}

export interface MemberLevelWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: LevelName;
  name_not?: LevelName;
  name_in?: LevelName[] | LevelName;
  name_not_in?: LevelName[] | LevelName;
  subscription?: String;
  subscription_not?: String;
  subscription_in?: String[] | String;
  subscription_not_in?: String[] | String;
  subscription_lt?: String;
  subscription_lte?: String;
  subscription_gt?: String;
  subscription_gte?: String;
  subscription_contains?: String;
  subscription_not_contains?: String;
  subscription_starts_with?: String;
  subscription_not_starts_with?: String;
  subscription_ends_with?: String;
  subscription_not_ends_with?: String;
  event_every?: EventWhereInput;
  event_some?: EventWhereInput;
  event_none?: EventWhereInput;
  AND?: MemberLevelWhereInput[] | MemberLevelWhereInput;
  OR?: MemberLevelWhereInput[] | MemberLevelWhereInput;
  NOT?: MemberLevelWhereInput[] | MemberLevelWhereInput;
}

export interface MemberLevelUpdateDataInput {
  name?: LevelName;
  subscription?: String;
  event?: EventUpdateManyWithoutMemberLevelInput;
}

export interface SpeakerWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  jobTitle?: String;
  jobTitle_not?: String;
  jobTitle_in?: String[] | String;
  jobTitle_not_in?: String[] | String;
  jobTitle_lt?: String;
  jobTitle_lte?: String;
  jobTitle_gt?: String;
  jobTitle_gte?: String;
  jobTitle_contains?: String;
  jobTitle_not_contains?: String;
  jobTitle_starts_with?: String;
  jobTitle_not_starts_with?: String;
  jobTitle_ends_with?: String;
  jobTitle_not_ends_with?: String;
  avatar?: String;
  avatar_not?: String;
  avatar_in?: String[] | String;
  avatar_not_in?: String[] | String;
  avatar_lt?: String;
  avatar_lte?: String;
  avatar_gt?: String;
  avatar_gte?: String;
  avatar_contains?: String;
  avatar_not_contains?: String;
  avatar_starts_with?: String;
  avatar_not_starts_with?: String;
  avatar_ends_with?: String;
  avatar_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: SpeakerWhereInput[] | SpeakerWhereInput;
  OR?: SpeakerWhereInput[] | SpeakerWhereInput;
  NOT?: SpeakerWhereInput[] | SpeakerWhereInput;
}

export interface MemberLevelUpdateManyWithoutEventInput {
  create?:
    | MemberLevelCreateWithoutEventInput[]
    | MemberLevelCreateWithoutEventInput;
  delete?: MemberLevelWhereUniqueInput[] | MemberLevelWhereUniqueInput;
  connect?: MemberLevelWhereUniqueInput[] | MemberLevelWhereUniqueInput;
  set?: MemberLevelWhereUniqueInput[] | MemberLevelWhereUniqueInput;
  disconnect?: MemberLevelWhereUniqueInput[] | MemberLevelWhereUniqueInput;
  update?:
    | MemberLevelUpdateWithWhereUniqueWithoutEventInput[]
    | MemberLevelUpdateWithWhereUniqueWithoutEventInput;
  upsert?:
    | MemberLevelUpsertWithWhereUniqueWithoutEventInput[]
    | MemberLevelUpsertWithWhereUniqueWithoutEventInput;
  deleteMany?: MemberLevelScalarWhereInput[] | MemberLevelScalarWhereInput;
  updateMany?:
    | MemberLevelUpdateManyWithWhereNestedInput[]
    | MemberLevelUpdateManyWithWhereNestedInput;
}

export interface MembershipWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  type?: MemberType;
  type_not?: MemberType;
  type_in?: MemberType[] | MemberType;
  type_not_in?: MemberType[] | MemberType;
  level?: MemberLevelWhereInput;
  member?: MemberWhereInput;
  AND?: MembershipWhereInput[] | MembershipWhereInput;
  OR?: MembershipWhereInput[] | MembershipWhereInput;
  NOT?: MembershipWhereInput[] | MembershipWhereInput;
}

export interface MemberLevelUpdateWithWhereUniqueWithoutEventInput {
  where: MemberLevelWhereUniqueInput;
  data: MemberLevelUpdateWithoutEventDataInput;
}

export interface MemberLevelSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MemberLevelWhereInput;
  AND?: MemberLevelSubscriptionWhereInput[] | MemberLevelSubscriptionWhereInput;
  OR?: MemberLevelSubscriptionWhereInput[] | MemberLevelSubscriptionWhereInput;
  NOT?: MemberLevelSubscriptionWhereInput[] | MemberLevelSubscriptionWhereInput;
}

export interface MemberLevelUpdateWithoutEventDataInput {
  name?: LevelName;
  subscription?: String;
}

export interface ApplicantSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ApplicantWhereInput;
  AND?: ApplicantSubscriptionWhereInput[] | ApplicantSubscriptionWhereInput;
  OR?: ApplicantSubscriptionWhereInput[] | ApplicantSubscriptionWhereInput;
  NOT?: ApplicantSubscriptionWhereInput[] | ApplicantSubscriptionWhereInput;
}

export interface MemberLevelUpsertWithWhereUniqueWithoutEventInput {
  where: MemberLevelWhereUniqueInput;
  update: MemberLevelUpdateWithoutEventDataInput;
  create: MemberLevelCreateWithoutEventInput;
}

export interface SubscriberCreateInput {
  email: String;
}

export interface MemberLevelScalarWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: LevelName;
  name_not?: LevelName;
  name_in?: LevelName[] | LevelName;
  name_not_in?: LevelName[] | LevelName;
  subscription?: String;
  subscription_not?: String;
  subscription_in?: String[] | String;
  subscription_not_in?: String[] | String;
  subscription_lt?: String;
  subscription_lte?: String;
  subscription_gt?: String;
  subscription_gte?: String;
  subscription_contains?: String;
  subscription_not_contains?: String;
  subscription_starts_with?: String;
  subscription_not_starts_with?: String;
  subscription_ends_with?: String;
  subscription_not_ends_with?: String;
  AND?: MemberLevelScalarWhereInput[] | MemberLevelScalarWhereInput;
  OR?: MemberLevelScalarWhereInput[] | MemberLevelScalarWhereInput;
  NOT?: MemberLevelScalarWhereInput[] | MemberLevelScalarWhereInput;
}

export type EventWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface MemberLevelUpdateManyWithWhereNestedInput {
  where: MemberLevelScalarWhereInput;
  data: MemberLevelUpdateManyDataInput;
}

export type MemberWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface MemberLevelUpdateManyDataInput {
  name?: LevelName;
  subscription?: String;
}

export interface MemberUpsertWithoutMembershipInput {
  update: MemberUpdateWithoutMembershipDataInput;
  create: MemberCreateWithoutMembershipInput;
}

export interface RegionUpdateOneInput {
  create?: RegionCreateInput;
  update?: RegionUpdateDataInput;
  upsert?: RegionUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: RegionWhereUniqueInput;
}

export interface MembershipUpdateInput {
  type?: MemberType;
  level?: MemberLevelUpdateOneInput;
  member?: MemberUpdateOneWithoutMembershipInput;
}

export interface RegionUpdateDataInput {
  name?: String;
}

export interface MembershipCreateInput {
  type?: MemberType;
  level?: MemberLevelCreateOneInput;
  member?: MemberCreateOneWithoutMembershipInput;
}

export interface RegionUpsertNestedInput {
  update: RegionUpdateDataInput;
  create: RegionCreateInput;
}

export interface MemberLevelUpdateInput {
  name?: LevelName;
  subscription?: String;
  event?: EventUpdateManyWithoutMemberLevelInput;
}

export interface SectorUpdateOneInput {
  create?: SectorCreateInput;
  update?: SectorUpdateDataInput;
  upsert?: SectorUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: SectorWhereUniqueInput;
}

export interface EventUpdateManyMutationInput {
  communityTag?: String;
  date?: String;
  description?: String;
  name?: String;
  time?: String;
  coordinator?: String;
  type?: EventType;
}

export interface SectorUpdateDataInput {
  description?: String;
  name?: String;
}

export type SpeakerWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SectorUpsertNestedInput {
  update: SectorUpdateDataInput;
  create: SectorCreateInput;
}

export type SponsorWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SpeakerUpdateManyInput {
  create?: SpeakerCreateInput[] | SpeakerCreateInput;
  update?:
    | SpeakerUpdateWithWhereUniqueNestedInput[]
    | SpeakerUpdateWithWhereUniqueNestedInput;
  upsert?:
    | SpeakerUpsertWithWhereUniqueNestedInput[]
    | SpeakerUpsertWithWhereUniqueNestedInput;
  delete?: SpeakerWhereUniqueInput[] | SpeakerWhereUniqueInput;
  connect?: SpeakerWhereUniqueInput[] | SpeakerWhereUniqueInput;
  set?: SpeakerWhereUniqueInput[] | SpeakerWhereUniqueInput;
  disconnect?: SpeakerWhereUniqueInput[] | SpeakerWhereUniqueInput;
  deleteMany?: SpeakerScalarWhereInput[] | SpeakerScalarWhereInput;
  updateMany?:
    | SpeakerUpdateManyWithWhereNestedInput[]
    | SpeakerUpdateManyWithWhereNestedInput;
}

export type SubscriberWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SpeakerUpdateWithWhereUniqueNestedInput {
  where: SpeakerWhereUniqueInput;
  data: SpeakerUpdateDataInput;
}

export interface BookingUpdateWithoutEventDataInput {
  member?: MemberUpdateOneInput;
}

export interface SpeakerUpdateDataInput {
  jobTitle?: String;
  avatar?: String;
  name?: String;
}

export interface BookingWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  event?: EventWhereInput;
  member?: MemberWhereInput;
  AND?: BookingWhereInput[] | BookingWhereInput;
  OR?: BookingWhereInput[] | BookingWhereInput;
  NOT?: BookingWhereInput[] | BookingWhereInput;
}

export interface SpeakerUpsertWithWhereUniqueNestedInput {
  where: SpeakerWhereUniqueInput;
  update: SpeakerUpdateDataInput;
  create: SpeakerCreateInput;
}

export interface SectorSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SectorWhereInput;
  AND?: SectorSubscriptionWhereInput[] | SectorSubscriptionWhereInput;
  OR?: SectorSubscriptionWhereInput[] | SectorSubscriptionWhereInput;
  NOT?: SectorSubscriptionWhereInput[] | SectorSubscriptionWhereInput;
}

export interface SpeakerScalarWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  jobTitle?: String;
  jobTitle_not?: String;
  jobTitle_in?: String[] | String;
  jobTitle_not_in?: String[] | String;
  jobTitle_lt?: String;
  jobTitle_lte?: String;
  jobTitle_gt?: String;
  jobTitle_gte?: String;
  jobTitle_contains?: String;
  jobTitle_not_contains?: String;
  jobTitle_starts_with?: String;
  jobTitle_not_starts_with?: String;
  jobTitle_ends_with?: String;
  jobTitle_not_ends_with?: String;
  avatar?: String;
  avatar_not?: String;
  avatar_in?: String[] | String;
  avatar_not_in?: String[] | String;
  avatar_lt?: String;
  avatar_lte?: String;
  avatar_gt?: String;
  avatar_gte?: String;
  avatar_contains?: String;
  avatar_not_contains?: String;
  avatar_starts_with?: String;
  avatar_not_starts_with?: String;
  avatar_ends_with?: String;
  avatar_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: SpeakerScalarWhereInput[] | SpeakerScalarWhereInput;
  OR?: SpeakerScalarWhereInput[] | SpeakerScalarWhereInput;
  NOT?: SpeakerScalarWhereInput[] | SpeakerScalarWhereInput;
}

export interface EventSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EventWhereInput;
  AND?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
  OR?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
  NOT?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
}

export interface SpeakerUpdateManyWithWhereNestedInput {
  where: SpeakerScalarWhereInput;
  data: SpeakerUpdateManyDataInput;
}

export interface SponsorUpdateInput {
  avatar?: String;
  name?: String;
}

export interface SpeakerUpdateManyDataInput {
  jobTitle?: String;
  avatar?: String;
  name?: String;
}

export interface RegionUpdateInput {
  name?: String;
}

export interface SponsorUpdateManyInput {
  create?: SponsorCreateInput[] | SponsorCreateInput;
  update?:
    | SponsorUpdateWithWhereUniqueNestedInput[]
    | SponsorUpdateWithWhereUniqueNestedInput;
  upsert?:
    | SponsorUpsertWithWhereUniqueNestedInput[]
    | SponsorUpsertWithWhereUniqueNestedInput;
  delete?: SponsorWhereUniqueInput[] | SponsorWhereUniqueInput;
  connect?: SponsorWhereUniqueInput[] | SponsorWhereUniqueInput;
  set?: SponsorWhereUniqueInput[] | SponsorWhereUniqueInput;
  disconnect?: SponsorWhereUniqueInput[] | SponsorWhereUniqueInput;
  deleteMany?: SponsorScalarWhereInput[] | SponsorScalarWhereInput;
  updateMany?:
    | SponsorUpdateManyWithWhereNestedInput[]
    | SponsorUpdateManyWithWhereNestedInput;
}

export interface MemberCreateWithoutMembershipInput {
  type?: MemberType;
  companyName?: String;
  email: String;
  isAdmin?: Boolean;
  jobTitle?: String;
  name?: String;
  password?: String;
  phoneNumber?: String;
  profilePicture?: String;
}

export interface SponsorUpdateWithWhereUniqueNestedInput {
  where: SponsorWhereUniqueInput;
  data: SponsorUpdateDataInput;
}

export interface MemberUpdateInput {
  type?: MemberType;
  membership?: MembershipUpdateOneWithoutMemberInput;
  companyName?: String;
  email?: String;
  isAdmin?: Boolean;
  jobTitle?: String;
  name?: String;
  password?: String;
  phoneNumber?: String;
  profilePicture?: String;
}

export interface SponsorUpdateDataInput {
  avatar?: String;
  name?: String;
}

export interface MemberLevelUpsertNestedInput {
  update: MemberLevelUpdateDataInput;
  create: MemberLevelCreateInput;
}

export interface SponsorUpsertWithWhereUniqueNestedInput {
  where: SponsorWhereUniqueInput;
  update: SponsorUpdateDataInput;
  create: SponsorCreateInput;
}

export interface SubscriberWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  AND?: SubscriberWhereInput[] | SubscriberWhereInput;
  OR?: SubscriberWhereInput[] | SubscriberWhereInput;
  NOT?: SubscriberWhereInput[] | SubscriberWhereInput;
}

export interface SponsorScalarWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  avatar?: String;
  avatar_not?: String;
  avatar_in?: String[] | String;
  avatar_not_in?: String[] | String;
  avatar_lt?: String;
  avatar_lte?: String;
  avatar_gt?: String;
  avatar_gte?: String;
  avatar_contains?: String;
  avatar_not_contains?: String;
  avatar_starts_with?: String;
  avatar_not_starts_with?: String;
  avatar_ends_with?: String;
  avatar_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: SponsorScalarWhereInput[] | SponsorScalarWhereInput;
  OR?: SponsorScalarWhereInput[] | SponsorScalarWhereInput;
  NOT?: SponsorScalarWhereInput[] | SponsorScalarWhereInput;
}

export interface RegionWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: RegionWhereInput[] | RegionWhereInput;
  OR?: RegionWhereInput[] | RegionWhereInput;
  NOT?: RegionWhereInput[] | RegionWhereInput;
}

export interface SponsorUpdateManyWithWhereNestedInput {
  where: SponsorScalarWhereInput;
  data: SponsorUpdateManyDataInput;
}

export interface SubscriberUpdateManyMutationInput {
  email?: String;
}

export interface SponsorUpdateManyDataInput {
  avatar?: String;
  name?: String;
}

export interface MemberUpdateWithoutMembershipDataInput {
  type?: MemberType;
  companyName?: String;
  email?: String;
  isAdmin?: Boolean;
  jobTitle?: String;
  name?: String;
  password?: String;
  phoneNumber?: String;
  profilePicture?: String;
}

export interface EventUpsertWithoutBookingsInput {
  update: EventUpdateWithoutBookingsDataInput;
  create: EventCreateWithoutBookingsInput;
}

export interface EventCreateInput {
  communityTag?: String;
  date?: String;
  description?: String;
  name: String;
  time?: String;
  agenda?: AgendaCreateOneInput;
  bookings?: BookingCreateManyWithoutEventInput;
  coordinator?: String;
  memberLevel?: MemberLevelCreateManyWithoutEventInput;
  region?: RegionCreateOneInput;
  sector?: SectorCreateOneInput;
  speakers?: SpeakerCreateManyInput;
  sponsors?: SponsorCreateManyInput;
  type?: EventType;
}

export interface MembershipUpdateWithoutMemberDataInput {
  type?: MemberType;
  level?: MemberLevelUpdateOneInput;
}

export interface MembershipUpdateOneWithoutMemberInput {
  create?: MembershipCreateWithoutMemberInput;
  update?: MembershipUpdateWithoutMemberDataInput;
  upsert?: MembershipUpsertWithoutMemberInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MembershipWhereUniqueInput;
}

export interface MemberUpdateDataInput {
  type?: MemberType;
  membership?: MembershipUpdateOneWithoutMemberInput;
  companyName?: String;
  email?: String;
  isAdmin?: Boolean;
  jobTitle?: String;
  name?: String;
  password?: String;
  phoneNumber?: String;
  profilePicture?: String;
}

export interface MemberUpdateOneInput {
  create?: MemberCreateInput;
  update?: MemberUpdateDataInput;
  upsert?: MemberUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MemberWhereUniqueInput;
}

export interface EventScalarWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  communityTag?: String;
  communityTag_not?: String;
  communityTag_in?: String[] | String;
  communityTag_not_in?: String[] | String;
  communityTag_lt?: String;
  communityTag_lte?: String;
  communityTag_gt?: String;
  communityTag_gte?: String;
  communityTag_contains?: String;
  communityTag_not_contains?: String;
  communityTag_starts_with?: String;
  communityTag_not_starts_with?: String;
  communityTag_ends_with?: String;
  communityTag_not_ends_with?: String;
  date?: String;
  date_not?: String;
  date_in?: String[] | String;
  date_not_in?: String[] | String;
  date_lt?: String;
  date_lte?: String;
  date_gt?: String;
  date_gte?: String;
  date_contains?: String;
  date_not_contains?: String;
  date_starts_with?: String;
  date_not_starts_with?: String;
  date_ends_with?: String;
  date_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  time?: String;
  time_not?: String;
  time_in?: String[] | String;
  time_not_in?: String[] | String;
  time_lt?: String;
  time_lte?: String;
  time_gt?: String;
  time_gte?: String;
  time_contains?: String;
  time_not_contains?: String;
  time_starts_with?: String;
  time_not_starts_with?: String;
  time_ends_with?: String;
  time_not_ends_with?: String;
  coordinator?: String;
  coordinator_not?: String;
  coordinator_in?: String[] | String;
  coordinator_not_in?: String[] | String;
  coordinator_lt?: String;
  coordinator_lte?: String;
  coordinator_gt?: String;
  coordinator_gte?: String;
  coordinator_contains?: String;
  coordinator_not_contains?: String;
  coordinator_starts_with?: String;
  coordinator_not_starts_with?: String;
  coordinator_ends_with?: String;
  coordinator_not_ends_with?: String;
  type?: EventType;
  type_not?: EventType;
  type_in?: EventType[] | EventType;
  type_not_in?: EventType[] | EventType;
  AND?: EventScalarWhereInput[] | EventScalarWhereInput;
  OR?: EventScalarWhereInput[] | EventScalarWhereInput;
  NOT?: EventScalarWhereInput[] | EventScalarWhereInput;
}

export type RegionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SectorUpdateManyMutationInput {
  description?: String;
  name?: String;
}

export interface RegionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RegionWhereInput;
  AND?: RegionSubscriptionWhereInput[] | RegionSubscriptionWhereInput;
  OR?: RegionSubscriptionWhereInput[] | RegionSubscriptionWhereInput;
  NOT?: RegionSubscriptionWhereInput[] | RegionSubscriptionWhereInput;
}

export interface SubscriberSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SubscriberWhereInput;
  AND?: SubscriberSubscriptionWhereInput[] | SubscriberSubscriptionWhereInput;
  OR?: SubscriberSubscriptionWhereInput[] | SubscriberSubscriptionWhereInput;
  NOT?: SubscriberSubscriptionWhereInput[] | SubscriberSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface SubscriberPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  email: String;
}

export interface SubscriberPreviousValuesPromise
  extends Promise<SubscriberPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
}

export interface SubscriberPreviousValuesSubscription
  extends Promise<AsyncIterator<SubscriberPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface Membership {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  type?: MemberType;
}

export interface MembershipPromise extends Promise<Membership>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<MemberType>;
  level: <T = MemberLevelPromise>() => T;
  member: <T = MemberPromise>() => T;
}

export interface MembershipSubscription
  extends Promise<AsyncIterator<Membership>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<MemberType>>;
  level: <T = MemberLevelSubscription>() => T;
  member: <T = MemberSubscription>() => T;
}

export interface ApplicantConnection {
  pageInfo: PageInfo;
  edges: ApplicantEdge[];
}

export interface ApplicantConnectionPromise
  extends Promise<ApplicantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ApplicantEdge>>() => T;
  aggregate: <T = AggregateApplicantPromise>() => T;
}

export interface ApplicantConnectionSubscription
  extends Promise<AsyncIterator<ApplicantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ApplicantEdgeSubscription>>>() => T;
  aggregate: <T = AggregateApplicantSubscription>() => T;
}

export interface Member {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  type?: MemberType;
  companyName?: String;
  email: String;
  isAdmin?: Boolean;
  jobTitle?: String;
  name?: String;
  password?: String;
  phoneNumber?: String;
  profilePicture?: String;
}

export interface MemberPromise extends Promise<Member>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<MemberType>;
  membership: <T = MembershipPromise>() => T;
  companyName: () => Promise<String>;
  email: () => Promise<String>;
  isAdmin: () => Promise<Boolean>;
  jobTitle: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  profilePicture: () => Promise<String>;
}

export interface MemberSubscription
  extends Promise<AsyncIterator<Member>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<MemberType>>;
  membership: <T = MembershipSubscription>() => T;
  companyName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  isAdmin: () => Promise<AsyncIterator<Boolean>>;
  jobTitle: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  profilePicture: () => Promise<AsyncIterator<String>>;
}

export interface ApplicantEdge {
  node: Applicant;
  cursor: String;
}

export interface ApplicantEdgePromise
  extends Promise<ApplicantEdge>,
    Fragmentable {
  node: <T = ApplicantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ApplicantEdgeSubscription
  extends Promise<AsyncIterator<ApplicantEdge>>,
    Fragmentable {
  node: <T = ApplicantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Sponsor {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  avatar?: String;
  name: String;
}

export interface SponsorPromise extends Promise<Sponsor>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  avatar: () => Promise<String>;
  name: () => Promise<String>;
}

export interface SponsorSubscription
  extends Promise<AsyncIterator<Sponsor>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  avatar: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSubscriber {
  count: Int;
}

export interface AggregateSubscriberPromise
  extends Promise<AggregateSubscriber>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubscriberSubscription
  extends Promise<AsyncIterator<AggregateSubscriber>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface SubscriberConnection {
  pageInfo: PageInfo;
  edges: SubscriberEdge[];
}

export interface SubscriberConnectionPromise
  extends Promise<SubscriberConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubscriberEdge>>() => T;
  aggregate: <T = AggregateSubscriberPromise>() => T;
}

export interface SubscriberConnectionSubscription
  extends Promise<AsyncIterator<SubscriberConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SubscriberEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSubscriberSubscription>() => T;
}

export interface Agenda {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  description?: String;
  image?: String;
  name: String;
}

export interface AgendaPromise extends Promise<Agenda>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  image: () => Promise<String>;
  name: () => Promise<String>;
}

export interface AgendaSubscription
  extends Promise<AsyncIterator<Agenda>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface Subscriber {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  email: String;
}

export interface SubscriberPromise extends Promise<Subscriber>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
}

export interface SubscriberSubscription
  extends Promise<AsyncIterator<Subscriber>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface AgendaSubscriptionPayload {
  mutation: MutationType;
  node: Agenda;
  updatedFields: String[];
  previousValues: AgendaPreviousValues;
}

export interface AgendaSubscriptionPayloadPromise
  extends Promise<AgendaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AgendaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AgendaPreviousValuesPromise>() => T;
}

export interface AgendaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AgendaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AgendaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AgendaPreviousValuesSubscription>() => T;
}

export interface SponsorEdge {
  node: Sponsor;
  cursor: String;
}

export interface SponsorEdgePromise extends Promise<SponsorEdge>, Fragmentable {
  node: <T = SponsorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SponsorEdgeSubscription
  extends Promise<AsyncIterator<SponsorEdge>>,
    Fragmentable {
  node: <T = SponsorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AgendaPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  description?: String;
  image?: String;
  name: String;
}

export interface AgendaPreviousValuesPromise
  extends Promise<AgendaPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  image: () => Promise<String>;
  name: () => Promise<String>;
}

export interface AgendaPreviousValuesSubscription
  extends Promise<AsyncIterator<AgendaPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSpeaker {
  count: Int;
}

export interface AggregateSpeakerPromise
  extends Promise<AggregateSpeaker>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSpeakerSubscription
  extends Promise<AsyncIterator<AggregateSpeaker>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Speaker {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  jobTitle?: String;
  avatar?: String;
  name: String;
}

export interface SpeakerPromise extends Promise<Speaker>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  jobTitle: () => Promise<String>;
  avatar: () => Promise<String>;
  name: () => Promise<String>;
}

export interface SpeakerSubscription
  extends Promise<AsyncIterator<Speaker>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  jobTitle: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SpeakerConnection {
  pageInfo: PageInfo;
  edges: SpeakerEdge[];
}

export interface SpeakerConnectionPromise
  extends Promise<SpeakerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SpeakerEdge>>() => T;
  aggregate: <T = AggregateSpeakerPromise>() => T;
}

export interface SpeakerConnectionSubscription
  extends Promise<AsyncIterator<SpeakerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SpeakerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSpeakerSubscription>() => T;
}

export interface ApplicantSubscriptionPayload {
  mutation: MutationType;
  node: Applicant;
  updatedFields: String[];
  previousValues: ApplicantPreviousValues;
}

export interface ApplicantSubscriptionPayloadPromise
  extends Promise<ApplicantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ApplicantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ApplicantPreviousValuesPromise>() => T;
}

export interface ApplicantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ApplicantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ApplicantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ApplicantPreviousValuesSubscription>() => T;
}

export interface SectorEdge {
  node: Sector;
  cursor: String;
}

export interface SectorEdgePromise extends Promise<SectorEdge>, Fragmentable {
  node: <T = SectorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SectorEdgeSubscription
  extends Promise<AsyncIterator<SectorEdge>>,
    Fragmentable {
  node: <T = SectorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSector {
  count: Int;
}

export interface AggregateSectorPromise
  extends Promise<AggregateSector>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSectorSubscription
  extends Promise<AsyncIterator<AggregateSector>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Booking {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
}

export interface BookingPromise extends Promise<Booking>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  event: <T = EventPromise>() => T;
  member: <T = MemberPromise>() => T;
}

export interface BookingSubscription
  extends Promise<AsyncIterator<Booking>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  event: <T = EventSubscription>() => T;
  member: <T = MemberSubscription>() => T;
}

export interface SectorConnection {
  pageInfo: PageInfo;
  edges: SectorEdge[];
}

export interface SectorConnectionPromise
  extends Promise<SectorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SectorEdge>>() => T;
  aggregate: <T = AggregateSectorPromise>() => T;
}

export interface SectorConnectionSubscription
  extends Promise<AsyncIterator<SectorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SectorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSectorSubscription>() => T;
}

export interface ApplicantPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  type?: MemberType;
  companyName?: String;
  email: String;
  jobTitle?: String;
  name?: String;
  phoneNumber?: String;
}

export interface ApplicantPreviousValuesPromise
  extends Promise<ApplicantPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<MemberType>;
  companyName: () => Promise<String>;
  email: () => Promise<String>;
  jobTitle: () => Promise<String>;
  name: () => Promise<String>;
  phoneNumber: () => Promise<String>;
}

export interface ApplicantPreviousValuesSubscription
  extends Promise<AsyncIterator<ApplicantPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<MemberType>>;
  companyName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  jobTitle: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRegion {
  count: Int;
}

export interface AggregateRegionPromise
  extends Promise<AggregateRegion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRegionSubscription
  extends Promise<AsyncIterator<AggregateRegion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RegionConnection {
  pageInfo: PageInfo;
  edges: RegionEdge[];
}

export interface RegionConnectionPromise
  extends Promise<RegionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RegionEdge>>() => T;
  aggregate: <T = AggregateRegionPromise>() => T;
}

export interface RegionConnectionSubscription
  extends Promise<AsyncIterator<RegionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RegionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRegionSubscription>() => T;
}

export interface SponsorSubscriptionPayload {
  mutation: MutationType;
  node: Sponsor;
  updatedFields: String[];
  previousValues: SponsorPreviousValues;
}

export interface SponsorSubscriptionPayloadPromise
  extends Promise<SponsorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SponsorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SponsorPreviousValuesPromise>() => T;
}

export interface SponsorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SponsorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SponsorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SponsorPreviousValuesSubscription>() => T;
}

export interface MembershipEdge {
  node: Membership;
  cursor: String;
}

export interface MembershipEdgePromise
  extends Promise<MembershipEdge>,
    Fragmentable {
  node: <T = MembershipPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MembershipEdgeSubscription
  extends Promise<AsyncIterator<MembershipEdge>>,
    Fragmentable {
  node: <T = MembershipSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BookingSubscriptionPayload {
  mutation: MutationType;
  node: Booking;
  updatedFields: String[];
  previousValues: BookingPreviousValues;
}

export interface BookingSubscriptionPayloadPromise
  extends Promise<BookingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookingPreviousValuesPromise>() => T;
}

export interface BookingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookingPreviousValuesSubscription>() => T;
}

export interface SubscriberSubscriptionPayload {
  mutation: MutationType;
  node: Subscriber;
  updatedFields: String[];
  previousValues: SubscriberPreviousValues;
}

export interface SubscriberSubscriptionPayloadPromise
  extends Promise<SubscriberSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubscriberPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubscriberPreviousValuesPromise>() => T;
}

export interface SubscriberSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubscriberSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubscriberSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubscriberPreviousValuesSubscription>() => T;
}

export interface BookingPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
}

export interface BookingPreviousValuesPromise
  extends Promise<BookingPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BookingPreviousValuesSubscription
  extends Promise<AsyncIterator<BookingPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MemberLevelEdge {
  node: MemberLevel;
  cursor: String;
}

export interface MemberLevelEdgePromise
  extends Promise<MemberLevelEdge>,
    Fragmentable {
  node: <T = MemberLevelPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MemberLevelEdgeSubscription
  extends Promise<AsyncIterator<MemberLevelEdge>>,
    Fragmentable {
  node: <T = MemberLevelSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Sector {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  description?: String;
  name: String;
}

export interface SectorPromise extends Promise<Sector>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  name: () => Promise<String>;
}

export interface SectorSubscription
  extends Promise<AsyncIterator<Sector>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMember {
  count: Int;
}

export interface AggregateMemberPromise
  extends Promise<AggregateMember>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMemberSubscription
  extends Promise<AsyncIterator<AggregateMember>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EventSubscriptionPayload {
  mutation: MutationType;
  node: Event;
  updatedFields: String[];
  previousValues: EventPreviousValues;
}

export interface EventSubscriptionPayloadPromise
  extends Promise<EventSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EventPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EventPreviousValuesPromise>() => T;
}

export interface EventSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EventSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EventSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EventPreviousValuesSubscription>() => T;
}

export interface MemberConnection {
  pageInfo: PageInfo;
  edges: MemberEdge[];
}

export interface MemberConnectionPromise
  extends Promise<MemberConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MemberEdge>>() => T;
  aggregate: <T = AggregateMemberPromise>() => T;
}

export interface MemberConnectionSubscription
  extends Promise<AsyncIterator<MemberConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MemberEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMemberSubscription>() => T;
}

export interface EventPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  communityTag?: String;
  date?: String;
  description?: String;
  name: String;
  time?: String;
  coordinator?: String;
  type?: EventType;
}

export interface EventPreviousValuesPromise
  extends Promise<EventPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  communityTag: () => Promise<String>;
  date: () => Promise<String>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  time: () => Promise<String>;
  coordinator: () => Promise<String>;
  type: () => Promise<EventType>;
}

export interface EventPreviousValuesSubscription
  extends Promise<AsyncIterator<EventPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  communityTag: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  time: () => Promise<AsyncIterator<String>>;
  coordinator: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<EventType>>;
}

export interface AggregateEvent {
  count: Int;
}

export interface AggregateEventPromise
  extends Promise<AggregateEvent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEventSubscription
  extends Promise<AsyncIterator<AggregateEvent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Region {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  name?: String;
}

export interface RegionPromise extends Promise<Region>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface RegionSubscription
  extends Promise<AsyncIterator<Region>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface EventConnection {
  pageInfo: PageInfo;
  edges: EventEdge[];
}

export interface EventConnectionPromise
  extends Promise<EventConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EventEdge>>() => T;
  aggregate: <T = AggregateEventPromise>() => T;
}

export interface EventConnectionSubscription
  extends Promise<AsyncIterator<EventConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EventEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEventSubscription>() => T;
}

export interface MemberSubscriptionPayload {
  mutation: MutationType;
  node: Member;
  updatedFields: String[];
  previousValues: MemberPreviousValues;
}

export interface MemberSubscriptionPayloadPromise
  extends Promise<MemberSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MemberPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MemberPreviousValuesPromise>() => T;
}

export interface MemberSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MemberSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MemberSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MemberPreviousValuesSubscription>() => T;
}

export interface BookingEdge {
  node: Booking;
  cursor: String;
}

export interface BookingEdgePromise extends Promise<BookingEdge>, Fragmentable {
  node: <T = BookingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookingEdgeSubscription
  extends Promise<AsyncIterator<BookingEdge>>,
    Fragmentable {
  node: <T = BookingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MemberPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  type?: MemberType;
  companyName?: String;
  email: String;
  isAdmin?: Boolean;
  jobTitle?: String;
  name?: String;
  password?: String;
  phoneNumber?: String;
  profilePicture?: String;
}

export interface MemberPreviousValuesPromise
  extends Promise<MemberPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<MemberType>;
  companyName: () => Promise<String>;
  email: () => Promise<String>;
  isAdmin: () => Promise<Boolean>;
  jobTitle: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  profilePicture: () => Promise<String>;
}

export interface MemberPreviousValuesSubscription
  extends Promise<AsyncIterator<MemberPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<MemberType>>;
  companyName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  isAdmin: () => Promise<AsyncIterator<Boolean>>;
  jobTitle: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  profilePicture: () => Promise<AsyncIterator<String>>;
}

export interface AggregateApplicant {
  count: Int;
}

export interface AggregateApplicantPromise
  extends Promise<AggregateApplicant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateApplicantSubscription
  extends Promise<AsyncIterator<AggregateApplicant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AgendaEdge {
  node: Agenda;
  cursor: String;
}

export interface AgendaEdgePromise extends Promise<AgendaEdge>, Fragmentable {
  node: <T = AgendaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AgendaEdgeSubscription
  extends Promise<AsyncIterator<AgendaEdge>>,
    Fragmentable {
  node: <T = AgendaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SubscriberEdge {
  node: Subscriber;
  cursor: String;
}

export interface SubscriberEdgePromise
  extends Promise<SubscriberEdge>,
    Fragmentable {
  node: <T = SubscriberPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubscriberEdgeSubscription
  extends Promise<AsyncIterator<SubscriberEdge>>,
    Fragmentable {
  node: <T = SubscriberSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MemberLevelSubscriptionPayload {
  mutation: MutationType;
  node: MemberLevel;
  updatedFields: String[];
  previousValues: MemberLevelPreviousValues;
}

export interface MemberLevelSubscriptionPayloadPromise
  extends Promise<MemberLevelSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MemberLevelPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MemberLevelPreviousValuesPromise>() => T;
}

export interface MemberLevelSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MemberLevelSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MemberLevelSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MemberLevelPreviousValuesSubscription>() => T;
}

export interface AggregateSponsor {
  count: Int;
}

export interface AggregateSponsorPromise
  extends Promise<AggregateSponsor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSponsorSubscription
  extends Promise<AsyncIterator<AggregateSponsor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MemberLevelPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  name?: LevelName;
  subscription?: String;
}

export interface MemberLevelPreviousValuesPromise
  extends Promise<MemberLevelPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<LevelName>;
  subscription: () => Promise<String>;
}

export interface MemberLevelPreviousValuesSubscription
  extends Promise<AsyncIterator<MemberLevelPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<LevelName>>;
  subscription: () => Promise<AsyncIterator<String>>;
}

export interface SpeakerEdge {
  node: Speaker;
  cursor: String;
}

export interface SpeakerEdgePromise extends Promise<SpeakerEdge>, Fragmentable {
  node: <T = SpeakerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SpeakerEdgeSubscription
  extends Promise<AsyncIterator<SpeakerEdge>>,
    Fragmentable {
  node: <T = SpeakerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MemberLevel {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  name?: LevelName;
  subscription?: String;
}

export interface MemberLevelPromise extends Promise<MemberLevel>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<LevelName>;
  subscription: () => Promise<String>;
  event: <T = FragmentableArray<Event>>(
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface MemberLevelSubscription
  extends Promise<AsyncIterator<MemberLevel>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<LevelName>>;
  subscription: () => Promise<AsyncIterator<String>>;
  event: <T = Promise<AsyncIterator<EventSubscription>>>(
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateMembership {
  count: Int;
}

export interface AggregateMembershipPromise
  extends Promise<AggregateMembership>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMembershipSubscription
  extends Promise<AsyncIterator<AggregateMembership>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MembershipSubscriptionPayload {
  mutation: MutationType;
  node: Membership;
  updatedFields: String[];
  previousValues: MembershipPreviousValues;
}

export interface MembershipSubscriptionPayloadPromise
  extends Promise<MembershipSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MembershipPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MembershipPreviousValuesPromise>() => T;
}

export interface MembershipSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MembershipSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MembershipSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MembershipPreviousValuesSubscription>() => T;
}

export interface AggregateMemberLevel {
  count: Int;
}

export interface AggregateMemberLevelPromise
  extends Promise<AggregateMemberLevel>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMemberLevelSubscription
  extends Promise<AsyncIterator<AggregateMemberLevel>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MembershipPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  type?: MemberType;
}

export interface MembershipPreviousValuesPromise
  extends Promise<MembershipPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<MemberType>;
}

export interface MembershipPreviousValuesSubscription
  extends Promise<AsyncIterator<MembershipPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<MemberType>>;
}

export interface MemberEdge {
  node: Member;
  cursor: String;
}

export interface MemberEdgePromise extends Promise<MemberEdge>, Fragmentable {
  node: <T = MemberPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MemberEdgeSubscription
  extends Promise<AsyncIterator<MemberEdge>>,
    Fragmentable {
  node: <T = MemberSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAgenda {
  count: Int;
}

export interface AggregateAgendaPromise
  extends Promise<AggregateAgenda>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAgendaSubscription
  extends Promise<AsyncIterator<AggregateAgenda>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EventEdge {
  node: Event;
  cursor: String;
}

export interface EventEdgePromise extends Promise<EventEdge>, Fragmentable {
  node: <T = EventPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EventEdgeSubscription
  extends Promise<AsyncIterator<EventEdge>>,
    Fragmentable {
  node: <T = EventSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RegionSubscriptionPayload {
  mutation: MutationType;
  node: Region;
  updatedFields: String[];
  previousValues: RegionPreviousValues;
}

export interface RegionSubscriptionPayloadPromise
  extends Promise<RegionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RegionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RegionPreviousValuesPromise>() => T;
}

export interface RegionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RegionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RegionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RegionPreviousValuesSubscription>() => T;
}

export interface BookingConnection {
  pageInfo: PageInfo;
  edges: BookingEdge[];
}

export interface BookingConnectionPromise
  extends Promise<BookingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookingEdge>>() => T;
  aggregate: <T = AggregateBookingPromise>() => T;
}

export interface BookingConnectionSubscription
  extends Promise<AsyncIterator<BookingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BookingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBookingSubscription>() => T;
}

export interface RegionPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  name?: String;
}

export interface RegionPreviousValuesPromise
  extends Promise<RegionPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface RegionPreviousValuesSubscription
  extends Promise<AsyncIterator<RegionPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SponsorPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  avatar?: String;
  name: String;
}

export interface SponsorPreviousValuesPromise
  extends Promise<SponsorPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  avatar: () => Promise<String>;
  name: () => Promise<String>;
}

export interface SponsorPreviousValuesSubscription
  extends Promise<AsyncIterator<SponsorPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  avatar: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface Applicant {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  type?: MemberType;
  companyName?: String;
  email: String;
  jobTitle?: String;
  name?: String;
  phoneNumber?: String;
}

export interface ApplicantPromise extends Promise<Applicant>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<MemberType>;
  companyName: () => Promise<String>;
  email: () => Promise<String>;
  jobTitle: () => Promise<String>;
  name: () => Promise<String>;
  phoneNumber: () => Promise<String>;
}

export interface ApplicantSubscription
  extends Promise<AsyncIterator<Applicant>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<MemberType>>;
  companyName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  jobTitle: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
}

export interface RegionEdge {
  node: Region;
  cursor: String;
}

export interface RegionEdgePromise extends Promise<RegionEdge>, Fragmentable {
  node: <T = RegionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RegionEdgeSubscription
  extends Promise<AsyncIterator<RegionEdge>>,
    Fragmentable {
  node: <T = RegionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SectorSubscriptionPayload {
  mutation: MutationType;
  node: Sector;
  updatedFields: String[];
  previousValues: SectorPreviousValues;
}

export interface SectorSubscriptionPayloadPromise
  extends Promise<SectorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SectorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SectorPreviousValuesPromise>() => T;
}

export interface SectorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SectorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SectorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SectorPreviousValuesSubscription>() => T;
}

export interface MemberLevelConnection {
  pageInfo: PageInfo;
  edges: MemberLevelEdge[];
}

export interface MemberLevelConnectionPromise
  extends Promise<MemberLevelConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MemberLevelEdge>>() => T;
  aggregate: <T = AggregateMemberLevelPromise>() => T;
}

export interface MemberLevelConnectionSubscription
  extends Promise<AsyncIterator<MemberLevelConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MemberLevelEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMemberLevelSubscription>() => T;
}

export interface AggregateBooking {
  count: Int;
}

export interface AggregateBookingPromise
  extends Promise<AggregateBooking>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookingSubscription
  extends Promise<AsyncIterator<AggregateBooking>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SpeakerPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  jobTitle?: String;
  avatar?: String;
  name: String;
}

export interface SpeakerPreviousValuesPromise
  extends Promise<SpeakerPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  jobTitle: () => Promise<String>;
  avatar: () => Promise<String>;
  name: () => Promise<String>;
}

export interface SpeakerPreviousValuesSubscription
  extends Promise<AsyncIterator<SpeakerPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  jobTitle: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SpeakerSubscriptionPayload {
  mutation: MutationType;
  node: Speaker;
  updatedFields: String[];
  previousValues: SpeakerPreviousValues;
}

export interface SpeakerSubscriptionPayloadPromise
  extends Promise<SpeakerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SpeakerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SpeakerPreviousValuesPromise>() => T;
}

export interface SpeakerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SpeakerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SpeakerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SpeakerPreviousValuesSubscription>() => T;
}

export interface Event {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  communityTag?: String;
  date?: String;
  description?: String;
  name: String;
  time?: String;
  coordinator?: String;
  type?: EventType;
}

export interface EventPromise extends Promise<Event>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  communityTag: () => Promise<String>;
  date: () => Promise<String>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  time: () => Promise<String>;
  agenda: <T = AgendaPromise>() => T;
  bookings: <T = FragmentableArray<Booking>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  coordinator: () => Promise<String>;
  memberLevel: <T = FragmentableArray<MemberLevel>>(
    args?: {
      where?: MemberLevelWhereInput;
      orderBy?: MemberLevelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  region: <T = RegionPromise>() => T;
  sector: <T = SectorPromise>() => T;
  speakers: <T = FragmentableArray<Speaker>>(
    args?: {
      where?: SpeakerWhereInput;
      orderBy?: SpeakerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sponsors: <T = FragmentableArray<Sponsor>>(
    args?: {
      where?: SponsorWhereInput;
      orderBy?: SponsorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  type: () => Promise<EventType>;
}

export interface EventSubscription
  extends Promise<AsyncIterator<Event>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  communityTag: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  time: () => Promise<AsyncIterator<String>>;
  agenda: <T = AgendaSubscription>() => T;
  bookings: <T = Promise<AsyncIterator<BookingSubscription>>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  coordinator: () => Promise<AsyncIterator<String>>;
  memberLevel: <T = Promise<AsyncIterator<MemberLevelSubscription>>>(
    args?: {
      where?: MemberLevelWhereInput;
      orderBy?: MemberLevelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  region: <T = RegionSubscription>() => T;
  sector: <T = SectorSubscription>() => T;
  speakers: <T = Promise<AsyncIterator<SpeakerSubscription>>>(
    args?: {
      where?: SpeakerWhereInput;
      orderBy?: SpeakerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sponsors: <T = Promise<AsyncIterator<SponsorSubscription>>>(
    args?: {
      where?: SponsorWhereInput;
      orderBy?: SponsorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  type: () => Promise<AsyncIterator<EventType>>;
}

export interface SectorPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  description?: String;
  name: String;
}

export interface SectorPreviousValuesPromise
  extends Promise<SectorPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  name: () => Promise<String>;
}

export interface SectorPreviousValuesSubscription
  extends Promise<AsyncIterator<SectorPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AgendaConnection {
  pageInfo: PageInfo;
  edges: AgendaEdge[];
}

export interface AgendaConnectionPromise
  extends Promise<AgendaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AgendaEdge>>() => T;
  aggregate: <T = AggregateAgendaPromise>() => T;
}

export interface AgendaConnectionSubscription
  extends Promise<AsyncIterator<AgendaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AgendaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAgendaSubscription>() => T;
}

export interface MembershipConnection {
  pageInfo: PageInfo;
  edges: MembershipEdge[];
}

export interface MembershipConnectionPromise
  extends Promise<MembershipConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MembershipEdge>>() => T;
  aggregate: <T = AggregateMembershipPromise>() => T;
}

export interface MembershipConnectionSubscription
  extends Promise<AsyncIterator<MembershipConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MembershipEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMembershipSubscription>() => T;
}

export interface SponsorConnection {
  pageInfo: PageInfo;
  edges: SponsorEdge[];
}

export interface SponsorConnectionPromise
  extends Promise<SponsorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SponsorEdge>>() => T;
  aggregate: <T = AggregateSponsorPromise>() => T;
}

export interface SponsorConnectionSubscription
  extends Promise<AsyncIterator<SponsorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SponsorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSponsorSubscription>() => T;
}

export type Long = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Agenda",
    embedded: false
  },
  {
    name: "Applicant",
    embedded: false
  },
  {
    name: "Booking",
    embedded: false
  },
  {
    name: "Event",
    embedded: false
  },
  {
    name: "Member",
    embedded: false
  },
  {
    name: "MemberLevel",
    embedded: false
  },
  {
    name: "Membership",
    embedded: false
  },
  {
    name: "Region",
    embedded: false
  },
  {
    name: "Sector",
    embedded: false
  },
  {
    name: "Speaker",
    embedded: false
  },
  {
    name: "Sponsor",
    embedded: false
  },
  {
    name: "Subscriber",
    embedded: false
  },
  {
    name: "EventType",
    embedded: false
  },
  {
    name: "LevelName",
    embedded: false
  },
  {
    name: "MemberType",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `https://eu1.prisma.sh/kudakwashe-mupeni/ndf-api/dev`,
  secret: `mysecret123`
});
export const prisma = new Prisma();
